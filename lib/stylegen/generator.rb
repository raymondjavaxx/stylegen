require 'dry/inflector'
require 'stylegen/version'

module Stylegen
  class Generator
    def initialize(data)
      @data = data
      @file = File.open(data["output_path"].to_s, "w")
    end

    def system_name
      @data["system_name"] || "Theme"
    end

    def camelized_system_name
      inflector.camelize_lower(inflector.underscore(system_name))
    end

    def access_level
      @data["access_level"] || "internal"
    end

    def inflector
      @inflector ||= Dry::Inflector.new
    end

    def out(line)
      @file << line << "\n"
    end

    def generate
      _generate_header
      _generate_enums
      _generate_lut
      _generate_extensions
    end

    def _generate_header
      out "// Autogenerated by stylegen (v#{Stylegen::VERSION})"
      out "// DO NOT EDIT"
      out ""
      out "import UIKit"
      out ""
    end

    def _generate_enums
      out "#{access_level} enum #{system_name}Color: Int {"

      @data["colors"].each do |key, value|
        out "    case #{inflector.camelize_lower(key)}"
      end

      out "}"
      out ""
    end

    def _generate_extensions
      out "#{access_level} extension #{system_name}Color {"
      out ""
      out "    var uiColor: UIColor {"
      out "        guard let color = _colorLUT[self] else {"
      out "            preconditionFailure(\"Color not found\")"
      out "        }"
      out ""
      out "        return color"
      out "    }"
      out ""
      out "}"
      out ""

      out "#{access_level} extension UIColor {"
      out ""
      out "    @inline(__always)"
      out "    static func #{camelized_system_name}(_ color: #{system_name}Color) -> UIColor {"
      out "       return color.uiColor"
      out "    }"
      out ""
      out "}"
      out ""

      out "#{access_level} extension CGColor {"
      out ""
      out "    @inline(__always)"
      out "    static func #{camelized_system_name}(_ color: #{system_name}Color) -> CGColor {"
      out "       return color.uiColor.cgColor"
      out "    }"
      out ""
      out "}"
      out ""

      out "private extension UIColor {"
      out ""
      out "    convenience init(light: UIColor, dark: UIColor) {"
      out "        if #available(iOS 13.0, *) {"
      out "            self.init(dynamicProvider: { (traits: UITraitCollection) -> UIColor in"
      out "                switch traits.userInterfaceStyle {"
      out "                case .dark:"
      out "                    return dark"
      out "                default:"
      out "                    return light"
      out "                }"
      out "            })"
      out "        } else {"
      out "            self.init(cgColor: light.cgColor)"
      out "        }"
      out "    }"
      out ""
      out "    convenience init(base: UIColor, elevated: UIColor) {"
      out "        if #available(iOS 13.0, *) {"
      out "            self.init(dynamicProvider: { (traits: UITraitCollection) -> UIColor in"
      out "                switch traits.userInterfaceLevel {"
      out "                case .elevated:"
      out "                    return elevated"
      out "                default:"
      out "                    return base"
      out "                }"
      out "            })"
      out "        } else {"
      out "            self.init(cgColor: base.cgColor)"
      out "        }"
      out "    }"
      out ""
      out "}"
    end

    def _generate_lut
      out "private let _colorLUT: [#{system_name}Color: UIColor] = ["

      @data["colors"].each do |key, value|
        out "    .#{inflector.camelize_lower(key)}: #{_generate_color(value)},"
      end

      out "]"
      out ""
    end

    def _generate_color(data, indent_level = 4)
      if data.key?("color")
        Color.from_hex(data["color"], data["alpha"]).to_s(indent_level)
      elsif data.key?("light")
        LightDarkColor.new(
            _generate_color(data["light"], indent_level + 4),
            _generate_color(data["dark"], indent_level + 4)
        ).to_s(indent_level)
      elsif data.key?("base")
        BaseElevatedColor.new(
            _generate_color(data["base"], indent_level + 4),
            _generate_color(data["elevated"], indent_level + 4)
        ).to_s(indent_level)
      end
    end
  end
end
